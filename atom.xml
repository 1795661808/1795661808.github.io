<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MouZaiSi-Demo.github.io/</id>
    <title>某在斯_Dome </title>
    <updated>2021-01-10T03:14:08.318Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MouZaiSi-Demo.github.io/"/>
    <link rel="self" href="https://MouZaiSi-Demo.github.io/atom.xml"/>
    <subtitle>MouZaiSi&apos;s Blogs</subtitle>
    <logo>https://MouZaiSi-Demo.github.io/images/avatar.png</logo>
    <icon>https://MouZaiSi-Demo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 某在斯_Dome </rights>
    <entry>
        <title type="html"><![CDATA[增广矩阵的秩的意义是什么？]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/zeng-guang-ju-zhen-de-zhi-de-yi-yi-shi-shi-me/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/zeng-guang-ju-zhen-de-zhi-de-yi-yi-shi-shi-me/">
        </link>
        <updated>2021-01-10T02:55:21.000Z</updated>
        <content type="html"><![CDATA[<p>在&quot;耻辱柱&quot;书中</p>
<figure data-type="image" tabindex="1"><img src="https://MouZaiSi-Demo.github.io//post-images/1610248380465.jpg" alt="" loading="lazy"></figure>
<p>在提到n元线性方程组的时候Ax=b 直接讲了矩阵A乘向量b与向量b之间秩的关系</p>
<p>虽然直接由方程组的解去理解定理3的三条 是十分容易的 但你知道意义吗?</p>
<p>尤其是对计算机学生来说,直观的意义你理解吗?</p>
<p>所以我做了以下几点思考</p>
<hr>
<blockquote>
<p>增广矩阵的秩与一般矩阵的秩表示的几何意义相同。（你别告诉我你不知道矩阵的秩的几何意义。）</p>
</blockquote>
<p>在【A】*【X】=【b】中</p>
<p>增广矩阵的秩与矩阵A的秩相同时，则表明增广矩阵所张成的空间与与【A】所张成的空间相同，表明了【b】在【A】所张成的空间中。此时非齐次线性方程组有解。</p>
<p>注意 增广矩阵的秩不可能小于原矩阵,而且在任何矩阵中新增新的向量都不应该导致该矩阵降秩。</p>
<p>如果在一个确认的矩阵[A]中新增一个或者多个向量得到矩阵[B]，若这些向量存在于[A]所张成的空间中，则[A]=[B],[B]的秩当然也会等于[A]的秩。如果新增的向量不存在于[A]所张成的空间中，[A]!=[B]且[B]的秩大于[A]。</p>
<p>根本原因就是矩阵的秩表示的是矩阵张成的列空间的维度,而维度越高的列空间所包含的信息越多.比如三维空间中所包含的信息就一定大于二维空间,而在一个确定的矩阵中添加向量则相当于在该矩阵表示的空间中添加信息.在一个高维空间中添加信息不可能使该空间降维,因为这已经违反了物理学的信息守恒.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录自己写的一个数组指针的BUG(太蠢了)]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/ji-lu-zi-ji-xie-de-yi-ge-shu-zu-zhi-zhen-de-bugtai-chun-liao/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/ji-lu-zi-ji-xie-de-yi-ge-shu-zu-zhi-zhen-de-bugtai-chun-liao/">
        </link>
        <updated>2021-01-08T16:23:18.000Z</updated>
        <content type="html"><![CDATA[<p>这是错误的demo 无法输入 一直无法进行 用vs调试以后只说数据读取错误</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 3

void sort(char* ptr[N]) {
	char * temp = NULL;
	int i, j;
	
	for (i = 0; i &lt; N; i++) {
		for (j = i + 1; j &lt; N; j++) {
			if (strcmp(ptr[i], ptr[j]) &gt; 0) {
				temp = ptr[i];
				ptr[i] = ptr[j];
				ptr[j] = temp;
			}
		}
	}
}
int main(void)
{
	char* str[3]; //= { &quot;Japan&quot;,&quot;China&quot;,&quot;German&quot; };
	int i = 0;

	for (i = 0; i &lt; N; i++)
		gets(str[i]);

	sort(str);

	for (i = 0; i &lt; N; i++)
		puts(str[i]);

	return 0;

}
</code></pre>
<hr>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 3

void sort(char* ptr[N]) {
	char * temp = NULL;
	int i, j;
	
	
	for (i = 0; i &lt; N; i++) {
		for (j = i + 1; j &lt; N; j++) {
			if (strcmp(ptr[i], ptr[j]) &gt; 0) {
				temp = ptr[i];
				ptr[i] = ptr[j];
				ptr[j] = temp;
			}
		}
	}
}

int main(void)
{
    char str1[50],str2[50],str3[50];
	char * str[3]={str1,str2,str3};
	int i = 0;

	for (i = 0; i &lt; N; i++)
		gets(str[i]);

	sort(str);

	for (i = 0; i &lt; N; i++)
		puts(str[i]);

	return 0;
}
</code></pre>
<p>问题出在 我指针数组里保存的指针都是常量 全是在常量区 无法进行输入 只能输出 不能改变</p>
<p>所以不能写死一个字符串常量 可以在前面建几个字符数组 然后把数组名放到指针数组里</p>
<p>贴一个大佬写的 <strong>这样写更标准但是更麻烦</strong>的demo<br>
<img src="https://MouZaiSi-Demo.github.io//post-images/1610123462583.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 递归]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/di-gui/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/di-gui/">
        </link>
        <updated>2021-01-07T09:57:56.000Z</updated>
        <content type="html"><![CDATA[<p>递归很典型实现的就是阶乘和Fibonacci数列</p>
<p>这次讲一讲FIbonacci数列</p>
<p>数学中，<strong>斐波那契数</strong>，通常表示为<em>˚F Ñ</em>，形成一个<a href="https://en.wikipedia.org/wiki/Integer_sequence">序列</a>，叫做<strong>斐波纳契数列</strong>，使得每个数字是两个前述者的总和，选自0和1。</p>
<p>因此，序列的开始是：</p>
<p>1 1 2  3  5  8  13  21  34...</p>
<p>递推公式</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mo>=</mo><mi>a</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">an = an-1 + an-2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p>
<p>用c写出来的代码就是</p>
<pre><code class="language-c">#define N 10000

long long  fibonacci(int n)//用longlong是因为fibonacci数列后面的值十分大
{
    if (n == 1 || n == 2)
        return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
</code></pre>
<p>但是 如果你递归fibinacci(100) 你会发现值迟迟不出现</p>
<p>这是因为每次都重复计算了</p>
<figure data-type="image" tabindex="1"><img src="https://MouZaiSi-Demo.github.io//post-images/1610013869532.jpg" alt="" loading="lazy"></figure>
<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>
<p>为此 提供一种思路 就是在第一次递归的时候 就把递归过的值给保存在数组中 再每次递归时先检查对应的数组 如果有值就直接调用而不去继续堆栈</p>
<p>还是用c写</p>
<pre><code class="language-c">#define N 10000

long long  f[N];//用来保存已经递归的值
long long  fibonacci(int n)
{
    if (n == 1 || n == 2)
        return 1;
    if (f[n] != 0)//检查该值有没有被递归过
        return f[n];
    return f[n] = fibonacci(n - 1) + fibonacci(n - 2);/*这里要注意 确保两个项的顺序不变 这样能确保右项能直接使用左项保存的值*/
}


</code></pre>
<p>这样的方法叫做记忆化搜索 也是实现的自顶向下的去搜索</p>
<p>你再去试试  f(100)轻轻松松 但是在f(1624)的时候会溢出longlong 这时候就得要用数组保存值了</p>
<hr>
<p>完整的输入输出</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define N 10000

long long  f[N];
long long  fibonacci(int n)
{
    if (n == 1 || n == 2)
        return 1;
    if (f[n] != 0)
        return f[n];
    return f[n] = fibonacci(n - 1) + fibonacci(n - 2);
}

int main(void)
{
    int x;
    scanf(&quot;%d&quot;, &amp;x);

    printf(&quot;%lld&quot;, fibonacci(x));
    
    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针和数组的羁绊]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/zhi-zhen-he-shu-zu-de-ji-ban/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/zhi-zhen-he-shu-zu-de-ji-ban/">
        </link>
        <updated>2021-01-06T13:10:15.000Z</updated>
        <content type="html"><![CDATA[<h4 id="int-p4和intp4的区别">int *p[4]和int(*p)[4]的区别</h4>
<p>int<em>p[4]因为 [ ] 比 * 的优先级高(见文章<a href="https://mouzaisi-demo.github.io/post/phe-pde-qu-bie/">(<em>p)++和</em>p++的区别?</a>)，所以p先于[ ]结合，是一个数组，然后再与</em>结合，所以这个数组跑p[4]的类型是int *，就是指向int的指针，就是“元素是指向整形数据的指针的数组”。每个元素都是一个指针，一共有4个元素。指针就是地址本身，而指针变量是用来存放地址的变量。</p>
<p>而int(<em>p)[4]，p先和</em>结合，意味着p是一个指针，他指向int [10]，即p是一个指向一个数组的指针，</p>
<p>比如a[4][10]，它包括a[0][10],a[1][10],a[2][10]，a[3][10],a[0],a[1],a[2],a[3]，可以表示成a[i]==*(a+i)；所以(*P)[10]，p可以等于a+i，p是指向大小为10的数组，p的增一减一是以一行为单位的（比如4行10列）。</p>
<p>实际int(*p)[4]就是一个二维数组，代表n行4列的数组.</p>
<hr>
<p>未完待续...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常国峰老师主编的《计算机导论》出现的补码错误]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/chang-guo-feng-lao-shi-zhu-bian-de-lesslessji-suan-ji-dao-lun-greatergreater-chu-xian-de-bu-ma-cuo-wu/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/chang-guo-feng-lao-shi-zhu-bian-de-lesslessji-suan-ji-dao-lun-greatergreater-chu-xian-de-bu-ma-cuo-wu/">
        </link>
        <updated>2021-01-06T07:58:57.000Z</updated>
        <content type="html"><![CDATA[<p>为了冲刺一下周四的计算机期末考试,我打算把学校发的计算机导论教材翻阅一遍(其实读过黑皮系列的计算机导论书和code)</p>
<p>在第17页的时候发现有违背code内容的地方 便上b乎搜寻问题便发现这位作者回答.</p>
<p>当然,我还是推荐大家阅读 <strong>《编码：隐匿在计算机软硬件背后的语言》(博文视点出品)</strong> <strong>(Code:The Hidden Language of Computer Hardware and Software)</strong></p>
<p><a href="https://www.zhihu.com/question/20458542/answer/40759880">常国峰老师主编的《计算机导论》出现的补码错误</a></p>
<p>作者：Simon Cao</p>
<hr>
<p>约定个屁！<br>
要说清这个问题，需要颠覆你对补码的理解</p>
<p>第一步，就像练北冥神功要先散功一样，先把你心中对原码，反码，补码的一套认识全部忘掉<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
V</p>
<p>第二步，正式开讲<br>
首先灌输一个新的概念叫，模<br>
什么是“模”，想象日常使用的钟表，它可以显示0～12点的时间，假设现在是2点钟，请用手动拨动时针的方式将时间减4小时，你会怎么做？<br>
有两种方式：</p>
<ol>
<li>逆时针将时针拨4小时</li>
<li>顺时针将时针拨8（12-4）小时</li>
</ol>
<p>这里要讲的是第二种方式，为什么顺时针拨12-4也可以达到和正常思维的第一种方式一样的位置。<br>
12就是模。<br>
同样的，如果是十进制的两位数，80-10 和 80＋90在不考虑百位数的基础上都是70。这里的90就是100-10得来的，这种情况下100就是模<br>
模就好比是一个极限，在它的范围内，两个相加等于模的数互为补数，还是举100的例子<br>
90和10， 55和45，68和32，互为补数<br>
在模的范围内做减法，可以将“X－Y”的减法变更为“X＋Y的补数“的加法，当然前提是不考虑百位数</p>
<p>思考题，<em>上面举的例子是大数减小数，那么如果是小数减大数会怎么样呢？</em><br>
如果是10-80，结果应该是－70，但如果按照10+（100-80），结果是30。<br>
而很明显－70和30不是一回事，这里也没有百位数的问题，这种情况应该怎么破？<br>
当初的那些先贤们想出来的办法很简单，就是把这两个数直接划上等号，正好顺便解决了负数的表达方式。再来仔细看看这两个数的关系：－70绝对值的补数就正好是30<br>
所以在计算机中，<strong>负数的表达方式就是它绝对值的补数</strong><br>
但是问题又来了，看起来这个解决方式很完美了，但别忘了，30他已经代表了正数的30了，现在又要用来代表负数的－70，谁知道它出现的时候到底是代表哪个数？<br>
为了解决这个问题，需要给这套规则划定一个范围，原来是0～99的正数，现在既然要用部分正数来代替负数了，那就要规定一个范围来使得一个数只代表一个含义，正好一人一半，0～49这个区间就代表正数，50～99的区间就用来代表各自补数的负值，例：98就代表－2<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
V</p>
<p>第三步，现在回到二进制的计算机世界<br>
8位二进制数一共可以表示2的8次方，256个数，即0～255 （别忘了0也要占一位的），他们的极限就是256，即256是8位二进制数的模 ，应该不难理解吧，同上十进制的两位数0～99的模是100。<br>
还是用二进制来说明清楚，8位二进制能表示的数的极限是<br>
1 1 1 1 1 1 1 1， 就是255，在这基础上加0 0 0 0 0 0 0 1，出现了进一位 即 1 0 0 0 0 0 0 0 0<br>
这个1 0 0 0 0 0 0 0 0就是8位二进制数的模，256</p>
<p>同样按照第二步讲的逻辑，一半的数0～127，代表其正数本身，另一半的数 128～255，代表其补数的负值，即“－1～－128”的区间。<br>
而 “X－Y”的减法 就用 “X＋Y的补数” 的加法来表示，完美！ 唯一需要注意的事情是任何计算的输入值和输出结果值都需要严格遵守－128～127的范围，一旦溢出就会报错。<br>
这也就是我们在编程里强调的为什么 byte＋byte还得是byte，int＋int还得是int，<strong>数据溢出问题也是每一个程序员都需要注意的问题</strong>。</p>
<p>这样一说是不是可以理解－128的补码是怎么来的了吧？ 他就是256-｜－128｜＝128<br>
二进制的128是不是就是1 0 0 0 0 0 0 0 ？<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
V</p>
<p>最终问题，那书和老师为什么要用原码，反码来讲补码 ？<br>
空穴来风，未必无因<br>
那是因为计算机就是这样求负数的补码的，我们在键盘上敲一个负数的时候，计算机要把它用补码的形式存储下来，还记得上面我们讲的补码是怎么来的吗？<br>
模－绝对值，这是不是个减法公式？但计算机没有减法逻辑，我们费了那么大的劲搞了一套补码的规则就是为了用加法来替代减法，但为了实现这么套规则，却跨不过一个坎，就是把负数计算成补码仍然是需要减法逻辑的。怎么办呢，那些伟大的先贤们 （膜拜）就想出了这么个办法：<br>
首位不变，其余位取反后，再加一<br>
｜<br>
｜<br>
｜<br>
｜<br>
｜<br>
V<br>
下面是吐槽<br>
不知道是哪个书呆子教书，照搬了机器的逻辑，把取反加一的方法当做补码的计算逻辑就这么教下来了。搞笑的是，还保留了补码这个名字，照理说这种教法应该叫 取反加一码 更合理，你还补什么啊？<br>
不仅如此，还搞出了个首位符号位的说法，弄出了个正0负0，还用负0来充当－128，真是不把人弄疯不罢休啊！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数学知识——素数专题]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/shu-xue-zhi-shi-su-shu-zhuan-ti/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/shu-xue-zhi-shi-su-shu-zhuan-ti/">
        </link>
        <updated>2021-01-05T15:05:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="判断素数is_prime">判断素数(is_prime)</h2>
<blockquote>
<p><a href="https://zh.wikipedia.org/zh-hk/%E8%B4%A8%E6%95%B0">质数</a></p>
<p>指在大于<a href="https://zh.wikipedia.org/wiki/1">1</a>的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0">自然数</a>中，除了1和该数自身外，无法被其他自然数<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E9%99%A4">整除</a>的数（也可定义为只有1与该数本身两个正因数的数）。</p>
</blockquote>
<p>1.质数的判定</p>
<p>先给出定义下的c++代码</p>
<pre><code class="language-c++">bool is_prime(int x)
{
    if (x &lt; 2) return false;
    for (int i = 2; i &lt;= x ; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
</code></pre>
<p>此时这个算法的时间复杂度是O(n) 效率比较低</p>
<p>素数有个性质 d | n =&gt; n/d | n  所以每次都枚举较小的那一个 也就是d 小于等于n/d</p>
<p>也就是d*d &lt;n =&gt;</p>
<hr>
<p>d&lt; sqrt(n)  此时时间复杂度就是O(根号n)</p>
<pre><code class="language-c++">bool is_prime(int x)
{
    if (x &lt; 2) return false;
    for (int i = 2; i &lt;= x/i ; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
</code></pre>
<p>——————试除法试根</p>
<hr>
<p>当然 可能很多人会像下面那样写</p>
<pre><code>for (int i = 2; i &lt;= sqrt(x) ; i ++ )
</code></pre>
<p>这样子不推荐 因为每一次循环都会执行一下sqrt函数 本身sqrt函数就比较慢</p>
<pre><code class="language-c++">for (int i = 2; i * i &lt;= x ; i ++ )
</code></pre>
<p>这样子看似可以 但是i如果是int 那么最大只有2的31次(正数) 当x非常接近于2的31次时 (i+1)的平方就溢出了 这样根据编码 会变成负数</p>
<hr>
<p>未完待续......</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12个Visual Studio调试效率技巧(搬运)]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/12-ge-visual-studio-diao-shi-xiao-lu-ji-qiao-ban-yun/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/12-ge-visual-studio-diao-shi-xiao-lu-ji-qiao-ban-yun/">
        </link>
        <updated>2021-01-05T13:34:39.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/157625640">12个Visual Studio调试效率技巧 - 芝麻麻雀的文章 - 知乎</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ (*p)++和*p++的区别?]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/phe-pde-qu-bie/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/phe-pde-qu-bie/">
        </link>
        <updated>2021-01-05T06:31:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="p">【 *p++ 】</h3>
<p>后缀递增 <code>++</code> 的优先级 比 取值运算符 <code>*</code> 高 ，<br>
所以 <code>*p++</code> 等价 <code>*(p++)</code> ，</p>
<p>后缀递增 <code>p++</code> 会先返回 <code>p</code> ，然后 <code>p = p + 1</code> 。<br>
所以 <code>*(p++)</code> 返回 <code>*p</code> ，然后把 <code>p</code> 的地址加一。<br>
（这个 加一 所增加的值取决于指针类型）</p>
<h3 id="p-2">【 (*p)++ 】</h3>
<p>括弧决定了结合优先级，取值运算符 <code>*</code> 会被先结合，<br>
所以会先对 <code>p</code> 的地址取值，取得地址上的数值。<br>
然后把这个值加一。</p>
<h2 id="主要区别"><strong>主要区别：</strong></h2>
<p><code>*p++</code> 是 返回 <code>*p</code> ，然后把 <code>p</code> 的地址加一。<br>
<code>(*p)++</code> 是取值 <code>p</code> ，然后把这个值加一，返回<code>(*p)</code> 。</p>
<p><code>*p++</code> 这个 <code>++</code> 的操作是针对地址。<br>
<code>(*p)++</code> 这个 <code>++</code> 的操作是针对地址上的值。</p>
<hr>
<p>这个区别主要是优先级造成的,所以下面贴上c语言的优先级<br>
<img src="https://MouZaiSi-Demo.github.io//post-images/1609828714533.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用netsh在windows上寻找已连过的wifi密码]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/li-yong-netsh-zai-windows-shang-xun-zhao-yi-lian-guo-de-wifi-mi-ma/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/li-yong-netsh-zai-windows-shang-xun-zhao-yi-lian-guo-de-wifi-mi-ma/">
        </link>
        <updated>2021-01-05T03:18:11.000Z</updated>
        <content type="html"><![CDATA[<p>首先得知道netsh是什么</p>
<p><strong>netsh简介</strong></p>
<p>是windows系统本身提供的功能强大的网络配置命令行工具,常用命令如下:</p>
<p>查看ip配置信息:</p>
<pre><code>netsh interface ip show config 
</code></pre>
<p>查看网络配置文件:</p>
<pre><code>netsh -c interface dump
</code></pre>
<p>开/关网卡:</p>
<pre><code>netsh int set int name=&quot;ethernet&quot; admin=enabled 

netsh int set int name=&quot;ethernet&quot;admin=disabled
</code></pre>
<p>查看所有tcp连接:</p>
<pre><code>netsh interface ip show tcpconnections 
</code></pre>
<p>设置本机ip、子网掩码、网关ip:</p>
<pre><code>netsh interface ip set address &quot;Local Area Connection&quot;static 192.168.1.2 255.255.255.0 192.168.1.1
</code></pre>
<p>开/关防火墙:</p>
<pre><code class="language-text">netsh firewall set opmode enable 

netsh firewall set opmode disable 
</code></pre>
<p>记不住也完全没关系,可以直接在命令行内输入netsh ?来获取接下来的命令</p>
<pre><code>下列指令有效:

此上下文中的命令:
..             - 移到上一层上下文级。
?              - 显示命令列表。
abort          - 丢弃在脱机模式下所做的更改。
add            - 在项目列表上添加一个配置项目。
advfirewall    - 更改到 `netsh advfirewall' 上下文。
alias          - 添加一个别名
bridge         - 更改到 `netsh bridge' 上下文。
bye            - 退出程序。
commit         - 提交在脱机模式中所做的更改。
delete         - 在项目列表上删除一个配置项目。
dhcpclient     - 更改到 `netsh dhcpclient' 上下文。
dnsclient      - 更改到 `netsh dnsclient' 上下文。
dump           - 显示一个配置脚本。
exec           - 运行一个脚本文件。
exit           - 退出程序。
firewall       - 更改到 `netsh firewall' 上下文。
help           - 显示命令列表。
http           - 更改到 `netsh http' 上下文。
interface      - 更改到 `netsh interface' 上下文。
ipsec          - 更改到 `netsh ipsec' 上下文。
lan            - 更改到 `netsh lan' 上下文。
mbn            - 更改到 `netsh mbn' 上下文。
namespace      - 更改到 `netsh namespace' 上下文。
netio          - 更改到 `netsh netio' 上下文。
offline        - 将当前模式设置成脱机。
online         - 将当前模式设置成联机。
p2p            - 更改到 `netsh p2p' 上下文。
popd           - 从堆栈上打开一个上下文。
pushd          - 将当前上下文放入堆栈。
quit           - 退出程序。
ras            - 更改到 `netsh ras' 上下文。
rpc            - 更改到 `netsh rpc' 上下文。
set            - 更新配置设置。
show           - 显示信息。
trace          - 更改到 `netsh trace' 上下文。
unalias        - 删除一个别名。
wcn            - 更改到 `netsh wcn' 上下文。
wfp            - 更改到 `netsh wfp' 上下文。
winhttp        - 更改到 `netsh winhttp' 上下文。
winsock        - 更改到 `netsh winsock' 上下文。
wlan           - 更改到 `netsh wlan' 上下文。

下列的子上下文可用:
 advfirewall bridge dhcpclient dnsclient firewall http interface ipsec lan mbn namespace netio p2p ras rpc trace wcn wfp winhttp winsock wlan
</code></pre>
<hr>
<p>现在回到主题</p>
<p>我们要利用cmd来获取已连接过的widows密码</p>
<p>1.Windows键+R</p>
<p>2.输入cmd 打开命令窗口</p>
<p>3.输入</p>
<ul>
<li>
<p>netsh wlan show profiles //这时候会出现连接过的WiFi名字</p>
</li>
<li>
<p>netsh wlan show profiles name=&quot;<em><strong>具体的WiFi名称</strong></em>&quot; key=clear //这样就显示了WiFi密码</p>
</li>
</ul>
<hr>
<p>以我的wifi来做例子</p>
<p>输入第一条命令后</p>
<pre><code>C:\Users\17956&gt;netsh wlan show profiles

接口 WLAN 上的配置文件:


组策略配置文件(只读)
---------------------------------
    &lt;无&gt;

用户配置文件
-------------
    所有用户配置文件 : mzs
    所有用户配置文件 : i-WZU
    所有用户配置文件 : WZU-free
    所有用户配置文件 : CMCC-pun2
    所有用户配置文件 : zhazha
    所有用户配置文件 : CMCC-YfQX
    所有用户配置文件 : 数zhazha
    所有用户配置文件 : CMCC-7gmf

</code></pre>
<p>输入第二条命令</p>
<pre><code>C:\Users\17956&gt;netsh wlan show profiles name=&quot;mzs&quot; key=clear

接口 WLAN 上的配置文件 mzs:
=======================================================================

已应用: 所有用户配置文件

配置文件信息
-------------------
    版本                   : 1
    类型                   : 无线局域网
    名称                   : mzs
    控制选项               :
        连接模式           : 自动连接
        网络广播           : 只在网络广播时连接
        AutoSwitch         : 请勿切换到其他网络
        MAC 随机化: 禁用

连接设置
---------------------
    SSID 数目              : 1
    SSID 名称              :“mzs”
    网络类型               : 结构
    无线电类型             : [ 任何无线电类型 ]
    供应商扩展名           : 不存在

安全设置
-----------------
    身份验证         : WPA2 - 个人
    密码                 : CCMP
    身份验证         : WPA2 - 个人
    密码                 : GCMP
    安全密钥               : 存在
    关键内容            : baibai123

费用设置
-------------
    费用                : 无限制
    阻塞                : 否
    接近数据限制        : 否
    过量数据限制        : 否
    漫游                : 否
    费用来源            : 默认

</code></pre>
<p>上面代码块中的关键内容就是这个wifi的wifi密码啦!</p>
<hr>
<p>注意:如果输入netsh的命令说 &quot;netsh不是内外部命令...&quot; 说明你的环境变量已经遭到改变(有可能是某些软件,或者你在配置编程环境变量的时候不小心改变).</p>
<p>拯救的方法很简单:</p>
<p>1.右键我的电脑</p>
<p>2.点高级系统设置(以Windows 10 为例)</p>
<p>3.点环境变量(N)...</p>
<p>4.找到名为path的变量 并双击它进入编辑环境变量界面</p>
<p>5.新建 输入%SystemRoot%\system32 按确定即可关闭所有界面</p>
<p>6.然后重新启动cmd再次输入netsh试试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[欧几里得算法(辗转相除法)]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/ou-ji-li-de-suan-fa-zhan-zhuan-xiang-chu-fa/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/ou-ji-li-de-suan-fa-zhan-zhuan-xiang-chu-fa/">
        </link>
        <updated>2021-01-04T01:11:32.000Z</updated>
        <content type="html"><![CDATA[<p>我们先给出由递归加上三目运算符极致优化过的函数封装。</p>
<pre><code class="language-c++">int gcd(int a,int b)
{
    return b ? gcd(b , a % b) : a; 
}
</code></pre>
<p>在这里由基础数论给出结论：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mi>a</mi><mo separator="true">,</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>=</mo><mo>&gt;</mo><mi>d</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>&gt;</mo><mi>d</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>x</mi><mi>a</mi><mo>+</mo><mi>y</mi><mi>b</mi><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>⊂</mo><mi>R</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">　</mi><mo>(</mo><mo>∗</mo><mo>)</mo><mo>−</mo><mo>−</mo><mo>−</mo><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">思</mi><mo>(</mo><mi mathvariant="normal">右</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">数</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">d/a,d/b =&gt; d/(a+b) =&gt; d/(xa+yb),其中x,y \subset R 　　(*) ---这里的/是除的意思(右边是被除数)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">　</span><span class="mopen">(</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord">/</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">思</span><span class="mopen">(</span><span class="mord cjk_fallback">右</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">数</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">要</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">明</mi><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo><mo>=</mo><mi>g</mi><mi>c</mi><mi>d</mi><mo>(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">　</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal">　</mi><mi>b</mi><mo>)</mo><mi mathvariant="normal">先</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">明</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">公</mi><mi mathvariant="normal">约</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">同</mi></mrow><annotation encoding="application/x-tex">要证明 gcd(a,b)=gcd(b,a　mod　b)
先证明 两者公约数相同
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">明</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord cjk_fallback">先</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">公</span><span class="mord cjk_fallback">约</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">同</span></span></span></span></span></p>
<p>先证明充分性：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">　</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi mathvariant="normal">　</mi><mi>b</mi><mo>=</mo><mi>a</mi><mo>−</mo><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>)</mo><mo>∗</mo><mi>b</mi><mo>−</mo><mo>−</mo><mo>−</mo><mi mathvariant="normal">注</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">的</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">法</mi></mrow><annotation encoding="application/x-tex">a　mod　b= a-(a/b)*b---注意这里的a/b是整数除法
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">法</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>−</mo><mo>(</mo><mi>a</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>)</mo><mo>∗</mo><mi>b</mi><mo>&lt;</mo><mo>=</mo><mo>&gt;</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo>∗</mo><mi>b</mi><mo>(</mo><mi>c</mi><mo>⊂</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a-(a/b)*b &lt;=&gt;a-c*b(c\subset R)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">又</mi><mi mathvariant="normal">由</mi><mo>∗</mo><mi mathvariant="normal">式</mi><mi mathvariant="normal">得</mi><mi mathvariant="normal">　</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>a</mi><mo separator="true">,</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>=</mo><mo>&gt;</mo><mi>d</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo>∗</mo><mi>b</mi><mo>)</mo><mi mathvariant="normal">　</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">毕</mi></mrow><annotation encoding="application/x-tex">又由*式得　d/a,d/b=&gt;d/(a-c*b)　证毕
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord cjk_fallback">又</span><span class="mord cjk_fallback">由</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">得</span><span class="mord cjk_fallback">　</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">毕</span></span></span></span></span></p>
<p>再证明必要性:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">再</mi><mi mathvariant="normal">由</mi><mo>∗</mo><mi mathvariant="normal">式</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">的</mi><mi>d</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo separator="true">,</mo><mi>d</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo>∗</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>&gt;</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo separator="true">,</mo><mi>d</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo>∗</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>∗</mo><mi>b</mi><mo>)</mo><mo>=</mo><mo>&gt;</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo separator="true">,</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>a</mi><mi mathvariant="normal">　</mi><mi mathvariant="normal">证</mi><mi mathvariant="normal">毕</mi></mrow><annotation encoding="application/x-tex">再由*式可的 d/b,d/(a-c*b) =&gt;d/b,d/(a-c*b+c*b)=&gt;d/b,d/a　证毕
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord cjk_fallback">再</span><span class="mord cjk_fallback">由</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord">/</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">　</span><span class="mord cjk_fallback">证</span><span class="mord cjk_fallback">毕</span></span></span></span></span></p>
<p>到这里,已经证明了(a,b)的公约数等于(b,a mod b)的公约数</p>
<p>所以他们的最大公约数相等</p>
<p>证毕</p>
]]></content>
    </entry>
</feed>