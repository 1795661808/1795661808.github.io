<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MouZaiSi-Demo.github.io/</id>
    <title>某在斯_Dome </title>
    <updated>2021-01-17T05:12:16.095Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MouZaiSi-Demo.github.io/"/>
    <link rel="self" href="https://MouZaiSi-Demo.github.io/atom.xml"/>
    <subtitle>MouZaiSi&apos;s Blogs</subtitle>
    <logo>https://MouZaiSi-Demo.github.io/images/avatar.png</logo>
    <icon>https://MouZaiSi-Demo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 某在斯_Dome </rights>
    <entry>
        <title type="html"><![CDATA[ 齐次线性方程组的基础解系]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/qi-ci-xian-xing-fang-cheng-zu-de-ji-chu-jie-xi/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/qi-ci-xian-xing-fang-cheng-zu-de-ji-chu-jie-xi/">
        </link>
        <updated>2021-01-17T05:11:10.000Z</updated>
        <content type="html"><![CDATA[<p>采取向量空间的观点， <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> <strong>元线性方程组的解都是</strong> <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> <strong>维向量</strong>。齐次线性方程组的解有一组重要的性质：对于一个方程组 <img src="https://www.zhihu.com/equation?tex=AX%3D0%2C" alt="[公式]" loading="lazy"> 若 <img src="https://www.zhihu.com/equation?tex=X_1%2CX_2" alt="[公式]" loading="lazy"> 是它的解， <img src="https://www.zhihu.com/equation?tex=k" alt="[公式]" loading="lazy"> 是一个数，则 <img src="https://www.zhihu.com/equation?tex=X_1%2BX_2" alt="[公式]" loading="lazy"> 和 <img src="https://www.zhihu.com/equation?tex=kX_1" alt="[公式]" loading="lazy"> 也是它的解。于是当 <img src="https://www.zhihu.com/equation?tex=AX%3D0" alt="[公式]" loading="lazy"> 有非零解时，存在一系列线性无关的解 <img src="https://www.zhihu.com/equation?tex=X_i%2C" alt="[公式]" loading="lazy"> 使得它的每个解都是这些解的线性组合，称这些解是它的一个基础解系。</p>
<p>进一步地，任何一个 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> 元齐次线性方程组的全体解是 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> 维向量空间的一个子空间，而此方程组的一个基础解系，就是这个子空间的一个基。</p>
<p>根据有关线性空间的结论，对于一个 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> 维线性空间，任取其中的一些向量，则这些向量构成此空间的基的充要条件是这些向量有 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]" loading="lazy"> 个，并且它们线性无关。所以同一齐次线性方程组的两个基础解系总是含有同样多个解，且确定了基础解系所含解的数目，对于这么多个解，它们是否构成基础解系，仅取决于它们是否线性无关。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.1.15复习线性代数 矩阵分块有感]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/2021115-fu-xi-xian-xing-dai-shu-ju-zhen-fen-kuai-you-gan/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/2021115-fu-xi-xian-xing-dai-shu-ju-zhen-fen-kuai-you-gan/">
        </link>
        <updated>2021-01-17T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<p>对于&quot;耻辱书中&quot;第六版的p46有一种矩阵分块的操作 可以让矩阵分块成新的大矩阵然后对其进行矩阵的操作是等价于对原矩阵进行矩阵的操作</p>
<p>G. Strang的Linear Algebra公开课中讲过 就算是高斯也没法一眼看出矩阵乘法能够分块 孟岩当年写过三篇《理解矩阵》，一开始就提出来“矩阵乘法为什么能分块”这个问题，到最后也没展开说，大概算是太监了</p>
<p>但是我找到一个比较好的解释方法:<strong>矩阵是对矢量的bai操作，可以看du做对n维空间上zhi的点的操作，dao相加是对一个矢量各自zhuan操作后shu再将操作后的矢量求和；相乘是将矢量操作一次后再操作一次给出的矢量。<br>
将空间分成子空间后，操作就变成这些子空间的操作了。对于乘法就是将不同子空间中的矢量操作到另外空间后再组合。<br>
例如5X5矩阵分解为(3+2)X(3+2)的4块矩阵后，对应的5维空间相应分解为3+2维的子空间，A11块代表将3维空间中矢量操作到3维空间的操作，A12代表将2维空间中矢量操作到3维空间的操作，以此类推。因此两次操作（矩阵相乘）可以归结为这些子空间中操作的组合喽。</strong></p>
<p>转自<a href="https://zhidao.baidu.com/question/330054200.html">矩阵计算的理论依据是什么？为什么矩阵的加、乘可以这样算？为什么矩阵可分块计算？</a>用户laocai10000的回答</p>
<hr>
<p>晚餐时间 看耻辱书p64-65<strong>猜测</strong>增广矩阵与分块矩阵有关,对元素内所有的分块进行初等变化等于对原矩阵的初等变化(前提是两个分块矩阵是同时进行初等变化的),</p>
<p>同时发现 求逆矩阵 (A,E)&gt;&gt;(E,A的可逆)与求AX=B的方法是一样的  都是通过有限次初等行变换(假设是P)将左边的分块矩阵变为E,右边的矩阵就是我们要的答案了) 那是因为 左边的分块矩阵进过有限次初等变化变成E推出 P是左边分块矩阵的逆矩阵 所以右边的分块矩阵就可以通过原式子做逆变化得到 我们想要的X了 .(此时 注意到 当X是向量就表示成x 当B是向量就表示成b 这样发现求线性方程组的Ax=b就是这种方法的特殊情况 所以增广矩阵就是这么来的 本质应该跟分块矩阵和初等变化是有关系的)</p>
<p>ps:等我寒假再过线性代数的时候用公式来表示  现在实属没时间</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021.1.12 C语言混沌的一天]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/2021112-c-yu-yan-hun-dun-de-yi-tian/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/2021112-c-yu-yan-hun-dun-de-yi-tian/">
        </link>
        <updated>2021-01-12T15:41:46.000Z</updated>
        <content type="html"><![CDATA[<p>今天状态很不好 哎水一下 递归文 救一下可怜的隔离cbh</p>
<pre><code class="language-c">void PrintN(int N) 
{    
	if(N == 0) return;  //[1]回归条件; 
    
	PrintN(N - 1);      //[2]递推;  
    
	printf(&quot;%d, &quot;, N);  //[3]当前 case 的工作; 
} 
</code></pre>
<p>这个函里，很清晰的展现了递归函数的组成部分：<br>
其中：[2] 和 [3] 组成基本逻辑。递归的 idea 和数学归纳法是同一个思路。<br>
数学归纳法是：<br>
（1）证明 case 0 成立；<br>
（2）如果 case i 成立 =&gt; 则 case ( i + 1 ) 成立。</p>
<p>在这个问题里，</p>
<p><strong>定义函数 PrintN ( by argument N )  means: 打印从 1 到 N 的一系列数字。</strong></p>
<p>因此，该函数的实现逻辑是：</p>
<p>（1）打印出从 1 到 N-1 的一系列数字。即调用 PrintN ( N - 1) ；这是 PrintN 的定义；<br>
（2）然后打印出 N；</p>
<p>分别对应了代码中的 [2], [3] 。</p>
<p>然后找出回归条件，本例子中，就是 PrintN 打印的一系列数字是从 ？ 开始的，假设从 N1 开始，则应该在 case N &lt; N1 时回归。也就是说回归条件是：</p>
<p>（3）if ( N &lt; N1 ) return;</p>
<p>本题目中，N1 = 1；对应于代码中的 [1];</p>
<p>因此上面的函数也等价于：</p>
<pre><code class="language-cpp">void PrintN(int N) 
{
    if(N &gt; 0) 
    {
        PrintN(N - 1);
        printf(&quot;%d, &quot;, N);
    }
} 
</code></pre>
<p>可以表述成一下的 call是调用的意思</p>
<p>call PrintN(4)</p>
<p>|-- call PrintN(3)</p>
<p>|     |--call PrintN(2)</p>
<p>|     |     |--call PrintN(1)</p>
<p>|     |     |     |--call PrintN(0); //return directly;</p>
<p>|     |     |     |--printf 1; // output 1, return from PrintN(1);</p>
<p>|     |     |--printf 2; //output 2, return from PrintN(2);</p>
<p>|     |--printf 3; //output 3, return from PrintN(3);</p>
<p>|--printf 4; //output 4, return from PrintN(4);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言中++比=优先级高，但为什么x=y++;是想把y的值赋值给x再y自加1]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/c-yu-yan-zhong-bi-you-xian-ji-gao-dan-wei-shi-me-xyshi-xiang-ba-y-de-zhi-fu-zhi-gei-x-zai-y-zi-jia-1/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/c-yu-yan-zhong-bi-you-xian-ji-gao-dan-wei-shi-me-xyshi-xiang-ba-y-de-zhi-fu-zhi-gei-x-zai-y-zi-jia-1/">
        </link>
        <updated>2021-01-10T13:02:00.000Z</updated>
        <content type="html"><![CDATA[<p>抖个机灵</p>
<p>C++界好像一直有这样一个笑话<br>
C++为了向后兼容C，它必须先照顾到C的种种问题，然后才能++。这就是自增操作符顺序的问题了。</p>
<hr>
<p>目前的理解:</p>
<p>后置自增操作符本身属性决定。</p>
<p>x=y++；</p>
<p>y++中后置++操作包含两步，一是取值，二是自增：</p>
<p>第一步取值，其结果是将y的值取出来，因为遇到=，所以将y值赋给x</p>
<p>第二步自增，其结果是将y的值加1<br>
这两步操作虽然可以分开来看，但却又是不可分割的。<br>
与之相关的、另一种容易误解的用法是：*ptr++（假设int *ptr=&amp;a[0]） <a href="https://mouzaisi-demo.github.io/post/phe-pde-qu-bie/">(*p)++和*p++的区别?</a></p>
<p>取值运算符<em>与后置自增运算符++有相同优先级，且结合方向从右至左，按理说，应该先执行ptr++，使得ptr=&amp;a[1]，从而</em>ptr++的值为a[1]。</p>
<p>然而，因为后置++的固有属性，<em>ptr++是先取ptr的值与</em>结合（第一步），再执行ptr自增加1操作（第二步），即*ptr++的值为a[0]。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性方程组什么时候无解？多个解？唯一解？]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/xian-xing-fang-cheng-zu-shi-me-shi-hou-wu-jie-duo-ge-jie-wei-yi-jie/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/xian-xing-fang-cheng-zu-shi-me-shi-hou-wu-jie-duo-ge-jie-wei-yi-jie/">
        </link>
        <updated>2021-01-10T07:49:34.000Z</updated>
        <content type="html"><![CDATA[<p>又是一篇水博客 冲冲冲 冲完期末考刷算法!!!</p>
<p><a href="https://blog.csdn.net/lynn0085/article/details/79375614">线性方程组什么时候无解？多个解？唯一解？</a></p>
<hr>
<p>在本文做些更加直观的解释:</p>
<p><em><strong>其实理论上 无论是齐次非齐次都是弄增广矩阵  只是齐次的没有必要这么搞</strong></em></p>
<p><strong>非齐次线性方程组:多解，无解，唯一解</strong></p>
<p>1.化简后的有效方程组个数，小于未知数个数。这样的方程组有无穷多个解化简后的有效方程组个数，小于未知数个数。这样的方程组有无穷多个解的意思是 <strong>A矩阵张成的空间是非满秩的 也就是有冗余即多余的基向量(比如有四个基向量(线性方程组中表示的是方程组的个数有四个),但张成这个空间其实只用其中三个 有一个是没用的 所以有效的基向量是三个)</strong> <strong>此时向量的秩也是非满秩的,也是有冗余的 又因为他们A矩阵张成的空间的维数与b向量的维数 相等  所以是有机会存在b在A矩阵张成的空间中的 且 因为冗余所以会有非常多的解</strong></p>
<p>2.化简后导出(0=d)形式的方程，方程组无解<strong>A矩阵的秩小于增广矩阵的秩 说明b向量不在A矩阵张成的列空间中 且b在比A矩阵张成空间的维度更高一些 根据二维世界难以理解三维世界的物理猜想 是得不到一个向量x根据A矩阵进行空间变化出b向量的</strong></p>
<p>3.不知道为什么该博客没有给出唯一解的例子 唯一解的例子是这样的:<strong>在第二条的基础上 我们知道非满秩有冗余 那么如果满秩 就是没有冗余 所以信息量是等价的 既然b在A矩阵的张成空间里 那么解就是唯一的</strong></p>
<p><strong>齐次线性方程组,非零解，零解</strong></p>
<p><em><strong>多个解叫做有非零解。唯一解叫做零解</strong></em></p>
<p>1.如果有效方程组个数小于未知数个数，叫做有非零解（多个解）如果有效方程组个数小于未知数个数，叫做有非零解（多个解）的意思是**同上 A矩阵有冗余 所以有非零解  **</p>
<p>2.如果等于，叫做只有零解（唯一解）<strong>满秩 没有冗余</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性代数计算器(web版)]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/xian-xing-dai-shu-ji-suan-qi-web-ban/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/xian-xing-dai-shu-ji-suan-qi-web-ban/">
        </link>
        <updated>2021-01-10T04:47:13.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://matrixcalc.org/zh/?from=mergeek.com">Matrix calculator</a></p>
<p>推荐一个行列式计算器</p>
<p>直接展示高斯消元法和莱布尼兹公式以及Montante's methond(https://MouZaiSi-Demo.github.io//post-images/1610255910507.png)!<br>
<a href="https://MouZaiSi-Demo.github.io//post-images/1610255919055.png"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[增广矩阵的秩的意义是什么？]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/zeng-guang-ju-zhen-de-zhi-de-yi-yi-shi-shi-me/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/zeng-guang-ju-zhen-de-zhi-de-yi-yi-shi-shi-me/">
        </link>
        <updated>2021-01-10T02:55:21.000Z</updated>
        <content type="html"><![CDATA[<p>在&quot;耻辱柱&quot;书中</p>
<figure data-type="image" tabindex="1"><img src="https://MouZaiSi-Demo.github.io//post-images/1610248380465.jpg" alt="" loading="lazy"></figure>
<p>在提到n元线性方程组的时候Ax=b 直接讲了矩阵A乘向量b与向量b之间秩的关系</p>
<p>虽然直接由方程组的解去理解定理3的三条 是十分容易的 但你知道意义吗?</p>
<p>尤其是对计算机学生来说,直观的意义你理解吗?</p>
<p>所以我做了以下几点思考</p>
<hr>
<blockquote>
<p>增广矩阵的秩与一般矩阵的秩表示的几何意义相同。（你别告诉我你不知道矩阵的秩的几何意义。）</p>
</blockquote>
<p>在【A】*【X】=【b】中</p>
<p>增广矩阵的秩与矩阵A的秩相同时，则表明增广矩阵所张成的空间与与【A】所张成的空间相同，表明了【b】在【A】所张成的空间中。此时非齐次线性方程组有解。</p>
<p>注意 增广矩阵的秩不可能小于原矩阵,而且在任何矩阵中新增新的向量都不应该导致该矩阵降秩。</p>
<p>如果在一个确认的矩阵[A]中新增一个或者多个向量得到矩阵[B]，若这些向量存在于[A]所张成的空间中，则[A]=[B],[B]的秩当然也会等于[A]的秩。如果新增的向量不存在于[A]所张成的空间中，[A]!=[B]且[B]的秩大于[A]。</p>
<p>根本原因就是矩阵的秩表示的是矩阵张成的列空间的维度,而维度越高的列空间所包含的信息越多.比如三维空间中所包含的信息就一定大于二维空间,而在一个确定的矩阵中添加向量则相当于在该矩阵表示的空间中添加信息.在一个高维空间中添加信息不可能使该空间降维,因为这已经违反了物理学的信息守恒.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记录自己写的一个数组指针的BUG(太蠢了)]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/ji-lu-zi-ji-xie-de-yi-ge-shu-zu-zhi-zhen-de-bugtai-chun-liao/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/ji-lu-zi-ji-xie-de-yi-ge-shu-zu-zhi-zhen-de-bugtai-chun-liao/">
        </link>
        <updated>2021-01-08T16:23:18.000Z</updated>
        <content type="html"><![CDATA[<p>这是错误的demo 无法输入 一直无法进行 用vs调试以后只说数据读取错误</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 3

void sort(char* ptr[N]) {
	char * temp = NULL;
	int i, j;
	
	for (i = 0; i &lt; N; i++) {
		for (j = i + 1; j &lt; N; j++) {
			if (strcmp(ptr[i], ptr[j]) &gt; 0) {
				temp = ptr[i];
				ptr[i] = ptr[j];
				ptr[j] = temp;
			}
		}
	}
}
int main(void)
{
	char* str[3]; //= { &quot;Japan&quot;,&quot;China&quot;,&quot;German&quot; };
	int i = 0;

	for (i = 0; i &lt; N; i++)
		gets(str[i]);

	sort(str);

	for (i = 0; i &lt; N; i++)
		puts(str[i]);

	return 0;

}
</code></pre>
<hr>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 3

void sort(char* ptr[N]) {
	char * temp = NULL;
	int i, j;
	
	
	for (i = 0; i &lt; N; i++) {
		for (j = i + 1; j &lt; N; j++) {
			if (strcmp(ptr[i], ptr[j]) &gt; 0) {
				temp = ptr[i];
				ptr[i] = ptr[j];
				ptr[j] = temp;
			}
		}
	}
}

int main(void)
{
    char str1[50],str2[50],str3[50];
	char * str[3]={str1,str2,str3};
	int i = 0;

	for (i = 0; i &lt; N; i++)
		gets(str[i]);

	sort(str);

	for (i = 0; i &lt; N; i++)
		puts(str[i]);

	return 0;
}
</code></pre>
<p>问题出在 我指针数组里保存的指针都是常量 全是在常量区 无法进行输入 只能输出 不能改变</p>
<p>所以不能写死一个字符串常量 可以在前面建几个字符数组 然后把数组名放到指针数组里</p>
<p>贴一个大佬写的 <strong>这样写更标准但是更麻烦</strong>的demo<br>
<img src="https://MouZaiSi-Demo.github.io//post-images/1610123462583.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 递归]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/di-gui/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/di-gui/">
        </link>
        <updated>2021-01-07T09:57:56.000Z</updated>
        <content type="html"><![CDATA[<p>递归很典型实现的就是阶乘和Fibonacci数列</p>
<p>这次讲一讲FIbonacci数列</p>
<p>数学中，<strong>斐波那契数</strong>，通常表示为<em>˚F Ñ</em>，形成一个<a href="https://en.wikipedia.org/wiki/Integer_sequence">序列</a>，叫做<strong>斐波纳契数列</strong>，使得每个数字是两个前述者的总和，选自0和1。</p>
<p>因此，序列的开始是：</p>
<p>1 1 2  3  5  8  13  21  34...</p>
<p>递推公式</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mo>=</mo><mi>a</mi><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">an = an-1 + an-2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></span></p>
<p>用c写出来的代码就是</p>
<pre><code class="language-c">#define N 10000

long long  fibonacci(int n)//用longlong是因为fibonacci数列后面的值十分大
{
    if (n == 1 || n == 2)
        return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
</code></pre>
<p>但是 如果你递归fibinacci(100) 你会发现值迟迟不出现</p>
<p>这是因为每次都重复计算了</p>
<figure data-type="image" tabindex="1"><img src="https://MouZaiSi-Demo.github.io//post-images/1610013869532.jpg" alt="" loading="lazy"></figure>
<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>
<p>为此 提供一种思路 就是在第一次递归的时候 就把递归过的值给保存在数组中 再每次递归时先检查对应的数组 如果有值就直接调用而不去继续堆栈</p>
<p>还是用c写</p>
<pre><code class="language-c">#define N 10000

long long  f[N];//用来保存已经递归的值
long long  fibonacci(int n)
{
    if (n == 1 || n == 2)
        return 1;
    if (f[n] != 0)//检查该值有没有被递归过
        return f[n];
    return f[n] = fibonacci(n - 1) + fibonacci(n - 2);/*这里要注意 确保两个项的顺序不变 这样能确保右项能直接使用左项保存的值*/
}


</code></pre>
<p>这样的方法叫做记忆化搜索 也是实现的自顶向下的去搜索</p>
<p>你再去试试  f(100)轻轻松松 但是在f(1624)的时候会溢出longlong 这时候就得要用数组保存值了</p>
<hr>
<p>完整的输入输出</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define N 10000

long long  f[N];
long long  fibonacci(int n)
{
    if (n == 1 || n == 2)
        return 1;
    if (f[n] != 0)
        return f[n];
    return f[n] = fibonacci(n - 1) + fibonacci(n - 2);
}

int main(void)
{
    int x;
    scanf(&quot;%d&quot;, &amp;x);

    printf(&quot;%lld&quot;, fibonacci(x));
    
    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[指针和数组的羁绊]]></title>
        <id>https://MouZaiSi-Demo.github.io/post/zhi-zhen-he-shu-zu-de-ji-ban/</id>
        <link href="https://MouZaiSi-Demo.github.io/post/zhi-zhen-he-shu-zu-de-ji-ban/">
        </link>
        <updated>2021-01-06T13:10:15.000Z</updated>
        <content type="html"><![CDATA[<h4 id="int-p4和intp4的区别">int *p[4]和int(*p)[4]的区别</h4>
<p>int<em>p[4]因为 [ ] 比 * 的优先级高(见文章<a href="https://mouzaisi-demo.github.io/post/phe-pde-qu-bie/">(<em>p)++和</em>p++的区别?</a>)，所以p先于[ ]结合，是一个数组，然后再与</em>结合，所以这个数组跑p[4]的类型是int *，就是指向int的指针，就是“元素是指向整形数据的指针的数组”。每个元素都是一个指针，一共有4个元素。指针就是地址本身，而指针变量是用来存放地址的变量。</p>
<p>而int(<em>p)[4]，p先和</em>结合，意味着p是一个指针，他指向int [10]，即p是一个指向一个数组的指针，</p>
<p>比如a[4][10]，它包括a[0][10],a[1][10],a[2][10]，a[3][10],a[0],a[1],a[2],a[3]，可以表示成a[i]==*(a+i)；所以(*P)[10]，p可以等于a+i，p是指向大小为10的数组，p的增一减一是以一行为单位的（比如4行10列）。</p>
<p>实际int(*p)[4]就是一个二维数组，代表n行4列的数组.</p>
<hr>
<p>未完待续...</p>
]]></content>
    </entry>
</feed>