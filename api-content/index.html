{"posts":[{"title":" 指针数组 char * 和 char []到底有什么不一样?","content":"## 数组指针做形参 把数组从主调函数传到被调函数时,我们可以传数组的首地址和数组长度就可以，为什么不是传递数组呢？还是为了效率，下面用代码说明： ```c void Output(char *p, int len); int main() { char str[] = &quot;HelloWorld HelloWorld HelloWorld HelloWorld HelloWorld HelloWorld &quot;; Output(str, strlen(str)); system(&quot;pause&quot;); return 0; } void Output(char *p, int len) { for (int i = 0; i &lt; len; ++i) { printf(&quot;%c&quot;, *(p + i)); } } ``` 如上，如果我们Output函数不是用指针的方式char *p，而是用数组的方式char p[]的话，有什么不一样？ 我们定义的数组str有65字节，调用函数的话会传递这65字节的数组。 char *p指针大小是4字节，只需要传递4字节的数据就可以了，不止少传递数据，执行起来也更快了。 PS: 指针大小可以打印sizeof(int**),sizeof(char**)去验证。(因为如果操作系统的位数不一样 那么存储指针变量p的位数可能就不同 ) ```c char namea[] = &quot;earth&quot;; char *pname = &quot;earth&quot;; ``` One is an array (the name namea refers to a block of characters). The other is a pointer to a single character (the name pname refers to a pointer, which just happens to point to the first character of a block of characters). Although the former will often decay into the latter, that's not always the case. Try doing a sizeof on them both to see what I mean. The size of the array is, well, the size of the array (six characters, including the terminal null). The size of the pointer is dependent on your pointer width (4 or 8, or whatever). The size of what pname points to is not the array, but the first character. It will therefore be 1. You can also move pointers with things like pname++ (unless they're declared constant, with something like char *const pname = ...; of course). You can't move an array name to point to it's second character (namea++;). ------- https://stackoverflow.com/questions/7886972/difference-between-char-and-char ","link":"https://MouZaiSi-Demo.github.io/post/zhi-zhen-shu-zu-char-he-char-dao-di-you-shi-me-bu-yi-yang/"}]}